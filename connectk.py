"""
Custom Connect K.
"""
import random
import os

# Player symbols to be used in the board in array for ease of changing and scaling
n_players = 2
rows = 6
columns = 7
connected_tokens = 4

player_symbols = ["X", "O"]

def clear_screen():
	"""
	Clears the terminal for Windows and Linux/MacOS.

	:return: None
	"""
	os.system('cls' if os.name == 'nt' else 'clear')

def print_rules():
	"""
	Prints the rules of the game.

	:return: None
	"""
	print("================= Rules =================")
	print("Connect K is a custom game where the")
	print("number of players, CPU players, board")
	print("size and number of tokens required to")
	print("win can be customized. The game objective")
	print("is to get k number of your pieces")
	print("in a row either horizontally, vertically")
	print("or diagonally. The game is played on a")
	print("mxn grid. The first player to get k")
	print("pieces consecutively wins the game. If the")
	print("grid is filled and no player has won,")
	print("the game is a draw.")
	print("=========================================")

def validate_input(prompt, valid_inputs):
	"""
	Repeatedly ask user for input until they enter an input
	within a set valid of options.

	:param prompt: The prompt to display to the user, string.
	:param valid_inputs: The range of values to accept, list
	:return: The user's input, int.
	"""
	selected = 0

	# Loops until valid input is received
	while selected != 1:
		choice = input(prompt)

		# Checks if input is valid then returns it
		if(choice in valid_inputs): 
			selected = 1
			return choice
		else:
			print("Invalid input, please try again.")

def game_settings():
	"""
	Prompts the user for the game settings and store them as runtime variables.
	Default game settings:
	- Number of players: 2
	- Player symbols: X and O (autogenerated based on number of players, max 26)
	- Number of rows: 6
	- Number of columns: 7
	- Number of connected tokens to win: 4

	:return: 1 if game settings are valid, 0 if invalid, int.
	"""
	global n_players, rows, columns, connected_tokens, player_symbols
	row_selected , column_selected = 0, 0
	confirmed_settings = 0

	# Repeatedly prompts the user for the game settings until a confirmation is received
	while not confirmed_settings:
		# Prompts the user for the number of players
		n_players = int(validate_input("Enter the number of players (2-26): ", [str(i) for i in range(2, 27)]))

		# Prompts the user for the number of rows
		while not row_selected:
			rows = int(input("Enter the number of rows (min. 3): "))

			if rows < 3:
				print("The number of rows must be at least 3.")
			else:
				row_selected = 1

		# Prompts the user for the number of columns
		while not column_selected:
			columns = int(input("Enter the number of columns (min. {}): ".format(n_players)))

			if columns < n_players:
				print("The number of columns must be at least {}.".format(n_players))
			else:
				column_selected = 1

		# Repeatedly prompts for the user until a valid input is received for the number of connected tokens required to win
		if rows < 4 or columns < 4:
			print("Auto set connected tokens to win to 3. (Any value less than 3 will make the game always a win for the first player.)")
			connected_tokens = 3
		else:
			connected_tokens = int(validate_input("Enter the number of connected tokens to win ({}-{}): ".format(3, min(rows, columns)), [str(i) for i in range(3, min(rows, columns) + 1)]))

		# Generates player symbols based on number of players based on ASCII values if it exceeds 2
		if n_players > 2:
			player_symbols = [chr(i + 65) for i in range(n_players)]
		else:
			player_symbols = ["X", "O"]

		# Prompts the user to confirm game settings with print-out of the game settings
		clear_screen()
		print("Game Settings Preview:")
		print("- Number of players: {}".format(n_players))
		print("- Number of connected tokens to win: {}".format(connected_tokens))
		print("- Board dimensions: {}x{}".format(rows, columns))
		print()

		confirmation = validate_input("Do you agree with the game settings?(Y\u0332es/N\u0332o): ", ["yes", "y", "no", "n", "Yes", "YES", "Y", "No", "NO", "N"])

		if(confirmation == "yes" or confirmation == "y" or confirmation == "Yes" or confirmation == "YES" or confirmation == "Y"):
			confirmed_settings = 1
			clear_screen()
			return 1
		elif(confirmation == "no" or confirmation == "n" or confirmation == "No" or confirmation == "NO" or confirmation == "N"):
			row_selected , column_selected = 0, 0
			confirmed_settings = 0

def create_board(rows, columns):
	"""
	Returns a 2D list of rows and 7 columns to represent
	the game board. Default cell value is 0.

	:param rows: The number of rows in the board, int, default 6. 
	:param columns: The number of columns in the board, int, default 7.
	:return: A 2D list of row x column dimensions .
	"""
	# Creates a 2D list of 0s with 6 rows and 7 columns
	board = [[0 for i in range(columns)] for j in range(rows)]

	# Returns the board to the caller
	return board

def print_board(board):
	"""
	Prints the game board to the console.

	:param board: The game board, 2D list of m x n dimensions.
	:return: None
	"""
	# Prints the board header consisting game name and player symbol
	print("=" + " Connect K ".center(len(board[0]) * 4, "="))

	# Prints player info two per line, with spacing
	for i in range(0, n_players, 2):
		left = "Player {}: {}".format(i + 1, player_symbols[i])
		if i + 1 < n_players:
			right = "Player {}: {}".format(i + 2, player_symbols[i + 1])
			print("{:<{width}} {}".format(left, right, width = len(board[0]) * 2 + 2))
		else:
			print(left)
	print()

	# Prints the play area of the board and its contents:
	# 1. Prints the column numbers
	for i in range(len(board[0])):
		print("  {}".format(i + 1), end = "")
		if(i < (len(board[0]) - 1)): print(" ", end = "")
	print()

	# 2. Prints the boxes of the board
	for i in range(len(board[0])):
		print(" ---", end = "")
	print()

	for i in range(len(board)):
		print("|", end = "")
		for j in range(len(board[i])):
			# Prints the contents of the box given the value of the cell 
			# (0 = empty, non-zero = corresponding player symbol)
			print(" {} ".format(" " if board[i][j] == 0 else player_symbols[board[i][j] - 1]), end = "|")
		print()
		for i in range(len(board[0])):
			print(" ---", end = "")
		print()
	# ===============================

	# 3. Prints the bottom section of the board
	for i in range(len(board[0]) * 4 + 1):
		print("=", end = "")
	print()

def drop_piece(board, player, column):
	"""
	Drops a piece into the game board in the given column.
	Please note that this function expects the column index
	to start at 1.

	:param board: The game board, 2D list of row x column dimensions.
	:param player: The player who is dropping the piece, int.
	:param column: The index of column to drop the piece into, int.
	:return: Row dropped into if piece was successfully dropped, False if not.
	"""
	for r in range(len(board) - 1, -1, -1):
		if(board[r][column - 1] == 0):
			board[r][column - 1] = player
			return True
		elif(r == 0):
			return False

def execute_player_turn(board, player):
	"""
	Prompts user for a legal move given the current game board
	and executes the move.

	:param board: The game board, 2D list of row x column dimensions.
	:param player: The player who is dropping the piece, int.
	:return: Row and Column that the piece was dropped into(int), if successful.
	"""
	while True:
		# Prompts player for a column to drop their piece into
		play = validate_input(
			"Player {}, please enter the column you would like to drop your piece into: ".format(player), 
			[str(i) for i in range(1, len(board[0]) + 1)]
		)

		if drop_piece(board, player, int(play)):
			return int(play)
		else:
			print("That column is full, please try again.")

def check_win(board, player):
	"""
	Checks if the specified player has won the game.
	
	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player to check for a win, int.
	:return: True if player has won, False otherwise.
	"""
	board_rows = len(board)
	board_columns = len(board[0])
	
	# Checks all positions on the board
	for row in range(board_rows):
		for col in range(board_columns):
			if board[row][col] == player:
				# Check horizontal (right)
				if col <= board_columns - connected_tokens:
					count = 0
					for i in range(connected_tokens):
						if board[row][col + i] == player:
							count += 1
						else:
							break
					if count == connected_tokens:
						return True
				
				# Checks vertical (down)
				if row <= board_rows - connected_tokens:
					count = 0
					for i in range(connected_tokens):
						if board[row + i][col] == player:
							count += 1
						else:
							break
					if count == connected_tokens:
						return True
				
				# Checks diagonal (down-right)
				if row <= board_rows - connected_tokens and col <= board_columns - connected_tokens:
					count = 0
					for i in range(connected_tokens):
						if board[row + i][col + i] == player:
							count += 1
						else:
							break
					if count == connected_tokens:
						return True
				
				# Checks diagonal (down-left)
				if row <= board_rows - connected_tokens and col >= connected_tokens - 1:
					count = 0
					for i in range(connected_tokens):
						if board[row + i][col - i] == player:
							count += 1
						else:
							break
					if count == connected_tokens:
						return True
	
	return False

def end_of_game(board):
	"""
	Checks if the game has ended with a winner or a draw.

	:param board: The game board, 2D list of m x n dimensions.
	:return: 0 if game is not over, player number if that player wins, n_players + 1 if draw.
	"""
	# Checks if any player has won
	for player in range(1, n_players + 1):
		if check_win(board, player):
			return player
	
	# Checks for draw - if board is full and no winner
	board_full = True
	for row in range(len(board)):
		for col in range(len(board[0])):
			if board[row][col] == 0:
				board_full = False
				break
		if not board_full:
			break
	
	if board_full:
		return n_players + 1  # Draw
	else:
		return 0  # Game continues

def local_k_player_game():
	"""
	Runs a local n_player game of Connect k.

	:return: None
	"""
	board = create_board(rows, columns)
	game_end = 0

	# Stores last played player and column
	last_played = [0, 0]

	# Game loop
	while not game_end:
		# Alternates from Player 1 to n_players
		for i in range(1, n_players + 1):
			clear_screen()
			print_board(board)
			# Prints last played piece and corresponding player
			if(last_played[0] != 0):
				print("Player {} dropped a piece into column {}".format(last_played[0], last_played[1]))

			# Stores last played piece and corresponding player and execute player turn
			last_played[0] = i
			last_played[1] = execute_player_turn(board, i)
			
			# Checks if the game has ended
			game_state = end_of_game(board)

			# If game has ended, prints the board and the winner
			if(game_state):
				game_end = 1
				clear_screen()
				print_board(board)
				if game_state == n_players + 1:
					print("Draw!")
				else:
					print("Player {} wins!".format(game_state))
				break

def main():
	"""
	Defines the main application loop.
    User chooses a type of game to play or to exit.

	:return: None
	"""
	playing = 1

	while playing:
		clear_screen()
		print("=============== Main Menu ===============")
		print("Welcome to Connect K!")
		print("Please select an option:")
		print("1. View Rules")
		print("2. Play a local game")
		print("3. Play a game against the computer")
		print("4. Exit")
		print("=========================================")

		choice = validate_input("Please enter your choice: ", ["1", "2", "3", "4"])

		# Processes user input
		if(choice == "1"): # Views rules
			clear_screen()
			print_rules()
		elif(choice == "2"): # Plays a local 2 player game
			clear_screen()
			game_settings()
			local_k_player_game()
		elif(choice == "3"): # Plays a game against the computer
			clear_screen()
			game_settings()
			print("CPU is always the even-numbered player.")
			cpu_player_choice = int(validate_input(
					"Please select a difficulty level (1 => Easy, 2 => Medium, 3 => Hard): ", 
					["1", "2", "3"]
				)
			)
			game_against_cpu(cpu_player_choice)
		elif(choice == "4"): # Exits
			clear_screen()
			playing = 0

def cpu_player_easy(board, player):
	"""
	Executes a move for the CPU on easy difficulty. This function 
	plays a randomly selected column.

	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: Column that the piece was dropped into, int.
	"""
	# Assigns loop variable 'successful_drop' to False
	successful_drop = False

	# Loops until there is a successful drop
	while successful_drop != True:
		# Attempts to drop a piece into a random column
		random_column = random.randint(1, len(board[0]))
		
		# If successful, updates successful_drop to True
		# Terminates loop and returns the random column
		successful_drop = drop_piece(board, player, random_column)
	return random_column

def cpu_player_medium(board, player):
	"""
	Executes a move for the CPU on medium difficulty. 
	It first checks for an immediate win and plays that move if possible. 
	If no immediate win is possible, it checks for an immediate win 
	for the opponent and blocks that move. If neither of these are 
	possible, it plays a random move.

	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: Column that the piece was dropped into, int.
	"""
	board_rows = len(board)
	board_columns = len(board[0])

	# Check for immediate win
	for column in range(board_columns):
		for row in reversed(range(board_rows)):
			if board[row][column] == 0:
				# Try dropping the player's piece to see if it results in a win
				board[row][column] = player
				if check_win(board, player):
					return column + 1
				else:
					# Undo the drop if it doesn't result in an immediate win
					board[row][column] = 0
				break  # Break out of the inner loop to move to the next column

	# Check for opponent's potential immediate win and block it
	for opponent in range(1, n_players + 1):
		if opponent != player:
			for column in range(board_columns):
				for row in reversed(range(board_rows)):
					if board[row][column] == 0:
						# Try dropping the opponent's piece to see if it results in a win
						board[row][column] = opponent
						if check_win(board, opponent):
							# Block the win
							board[row][column] = player
							return column + 1
						else:
							# Undo the drop if there is no potential immediate win for the opponent
							board[row][column] = 0
						break  # Break out of the inner loop to move to the next column

	# Random drop if no immediate win or block
	successful_drop = False
	
	while successful_drop != True:
		random_column = random.randint(1, board_columns)
		successful_drop = drop_piece(board, player, random_column)
		
	return random_column

def cpu_player_hard(board, player):
	"""
	Executes a move for the CPU on hard difficulty.
	This function creates a copy of the board to simulate moves.

	It first checks for an immediate win and plays that move if possible. 
	If no immediate win is possible, it checks for an immediate win 
	for the opponent and blocks that move. If neither of these are 
	possible, it plays in the center columns to get more
	winning combinations. If all the specified cells in the center columns  
	are occupied, it plays a random move.
	
	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: Column that the piece was dropped into, int.
	"""
	board_rows = len(board)
	board_columns = len(board[0])

	# Check for immediate win
	for column in range(board_columns):
		for row in reversed(range(board_rows)):
			if board[row][column] == 0:
				# Try dropping the player's piece to see if it results in a win
				board[row][column] = player
				if check_win(board, player):
					return column + 1
				else:
					# Undo the drop if it doesn't result in an immediate win
					board[row][column] = 0
				break  # Break out of the inner loop to move to the next column

	# Check for opponent's potential immediate win and block it
	for opponent in range(1, n_players + 1):
		if opponent != player:
			for column in range(board_columns):
				for row in reversed(range(board_rows)):
					if board[row][column] == 0:
						# Try dropping the opponent's piece to see if it results in a win
						board[row][column] = opponent
						if check_win(board, opponent):
							# Block the win
							board[row][column] = player
							return column + 1
						else:
							# Undo the drop if there is no immediate win possible for the opponent
							board[row][column] = 0
						break  # Break out of the inner loop to move to the next column

	# Prioritize center columns (if board is wide enough)
	center_col = board_columns // 2
	center_columns = []
	
	# Add center column(s) - handle both odd and even column counts
	if board_columns % 2 == 1:
		# Odd number of columns - true center exists
		center_columns = [center_col, center_col - 1, center_col + 1]
	else:
		# Even number of columns - two middle columns
		center_columns = [center_col - 1, center_col, center_col - 2, center_col + 1]
	
	# Try center columns first
	for col_idx in center_columns:
		if 0 <= col_idx < board_columns:
			for row in reversed(range(board_rows)):
				if board[row][col_idx] == 0:
					drop_piece(board, player, col_idx + 1)
					return col_idx + 1

	# Random drop if no strategic move is found
	successful_drop = False
	while successful_drop != True:
		random_column = random.randint(1, board_columns)
		successful_drop = drop_piece(board, player, random_column)
	
	return random_column

def cpu_player_selector(difficulty, board, player):
	"""
	Selects the CPU player function based on the difficulty level.

	:param difficulty: The difficulty level of the CPU player.
	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: The CPU player function.
	"""
	match difficulty:
		case 1:
			return cpu_player_easy(board, player)
		case 2:
			return cpu_player_medium(board, player)
		case 3:
			return cpu_player_hard(board, player)

def game_against_cpu(cpu_player: int):
	"""
	Runs a game of Connect K against the computer.

	:param cpu_player: The difficulty level of the CPU player. 1 => Easy, 2 => Medium, 3 => Hard.
	:return: None
	"""
	board = create_board(rows, columns)
	game_end = 0
	game_state = 0

	# Stores last played player and column [local_player, cpu_player]
	local_last_played = [0, 0]
	cpu_last_played = [0, 0]

	# Game loop
	while not game_end:
		# Alternates from Player 1 to n_players
		for i in range(n_players - 1):
			# Checks if game has ended
			if(cpu_last_played[1] != 0):
				game_state = end_of_game(board)

			if not game_state:
				clear_screen()
				print_board(board)

				# Prints local last played piece and corresponding player
				if(local_last_played[1] != 0):
					print("Player {} dropped a piece into column {}".format(local_last_played[0], local_last_played[1]))

				# Prints CPU last played piece and corresponding player
				if(cpu_last_played[1] != 0):
					print("Player {} dropped a piece into column {}".format(cpu_last_played[0], cpu_last_played[1]))

				# Stores local last played piece and corresponding player and executes player turn
				if(1 + 2 * i <= n_players):
					local_last_played[0] = 1 + 2 * i
					local_last_played[1] = execute_player_turn(board, 1 + 2 * i)

				game_state = end_of_game(board)
			# If game has ended, prints the board and the winner
			if(game_state):
				game_end = 1
				clear_screen()
				print_board(board)
				if game_state == n_players + 1:
					print("Draw!")
				else:
					print("Player {} wins!".format(game_state))
				break
			elif(2 + 2 * i <= n_players):
				# Stores CPU last played piece and corresponding player and executes player turn
				cpu_last_played[0] = 2 + 2 * i
				cpu_last_played[1] = cpu_player_selector(cpu_player, board, 2 + 2 * i)

if __name__ == "__main__":
	main()

